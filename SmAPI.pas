unit SmAPI;

interface

uses
  WinTypes, WinProcs, Dialogs, Forms, SysUtils;

const
  SM_API_IMAGE_MAX_PLANES = 4;
  SM_API_CAMERA_DEFAULT_FIFO_LEN = 2;

type
  SmWindowHandle = HWND;

  SmBool = Integer;

  SmSize2i = record
    W,H : Integer;
  end;

  SmCoord2I = record
    X,Y : Integer;
  end;

  SmCoord2f = record
    X,Y : Single;
  end;

  SmCoord3f = record
    X,Y,Z : Single;
  end;

  SmPixel = SmCoord2F;

  SmCoord2d = record
    X,Y : Double;
  end;

  SmFaceCoord = SmCoord3F;

  SmPos2F = SmCoord2F;
  SmPos3F = SmCoord3F;

  SmImageRect = record
    TopLeft : SmCoord2I;
    Size    : SmSize2I;
  end;
  PSmImageRect = ^SmImageRect;

  SmTime = record     // 12
    TimeS  : Int64;   // 8
    TimeUS : Integer; // 4
  end;

  SmRotEuler = record
    XRads,YRads,ZRads : Single; // radians
  end;

  SmStringHandle = Integer;

  SmEngineHandle = Integer;
  PSmEngineHandle = ^SmEngineHandle;

  SmEngineHeadPoseData = record
    HeadPos     : SmPos3F;    // Position of the head relative to the camera.
    LeftEyePos  : SmPos3F;    // Position of the left eyeball center relative to the camera.
    RightEyePos : SmPos3F;    // Position of the right eyeball center relative to the camera.
    HeadRot     : SmRotEuler; // Rotation of the head XYZ axis
    Confidence  : Single;     // Confidence of the head-pose measurement [0..1] - 0 is bad
  end;
  PSmEngineHeadPoseData = ^SmEngineHeadPoseData;

  SmFaceTexCoord = record
    U,V : Single;
  end;

  SmFaceLandMark = record
    ID  : Integer;        // Valid id values are >= 0. @see @ref sm_api_flm_standard */
    FC  : SmFaceCoord;    // Position of the face landmark in the head-pose reference frame (face coordinates) */
    FTC : SmFaceTexCoord; // Position of the face landmark on the 2D face-texture plane (face texture coordinates) */
    WC  : SmCoord3F;      // Position of the face landmark in the world coordinate frame (world coordinates).*/
    PC  : SmPixel;        // Position of the face landmark in the 2D image pixel ccoordinate frame (pixel coordinates). */
  end;
  PSmFaceLandMark = ^SmFaceLandMark;

  SmImageCode = Integer;

  SmImageMemoryCopyMode = Integer;

  SmImageInfo = record
    Format    : SmImageCode;                                  // The image format. @see smImageCode. */
    Res       : SmSize2I;                                     // The resolution (width, height) of the image in pixels. */
    StepBytes : array[1..SM_API_IMAGE_MAX_PLANES] of Integer; // The number of bytes per scanline (row), including any memory padding, for each image plane. */
    PlaneAddr : array[1..SM_API_IMAGE_MAX_PLANES] of PByte;   // Pointers to the start address of image data for each image plane. */
    UserData  : Pointer;                                      // You can optionally set this to the 'this' pointer of an object that owns image data.
  end;                                                        // If the image is generated by the API, then this value is always 0. */
  PSmImageInfo = ^SmImageInfo;

// Defines a texture image of a face, a boundary region (mask) as well as scale
// and offset parameters to convert between face-coordinates and pixels in the texture image.
  SmFaceTexture = record
    TextureType      : Integer;         // Type of the texture. */
    ImageInfo        : SmImageInfo;     // Texture image info. You can create an image from this info using smImageCreateFromInfo() */
    NumMaskLandMarks : Integer;         // Number of landmarks used to define the mask region (outline) of the face texture. */
    MaskLandMarks    : PSmFaceLandMark; // List of landmarks used to define the mask region (outline) of the face texture. This memory is allocated by the API, do not free it. */
    Origin           : SmPos2F;         // Face origin pixel coordinate. @see smFaceTexCoordToPixel */
    Scale            : SmCoord2F;       // Scale factor in convert between pixels and face texture coordinates. @see smFaceTexCoordToPixel */
  end;
  PSmFaceTexture = ^SmFaceTexture;

// Contains facial landmarks and texture.
// This data may be produced by face algorithms. The contents of the structure
// are dynamic, depending on how many face landmarks are able to be located and
// if a facial texture image can be generated.
  SmEngineFaceData = record
    NumLandMarks : Integer;         // Number of landmarks being tracked
    LandMarks    : PSmFaceLandMark; // Pointer to allocated array of size num_landmarks*sizeof(smFaceLandmark). Do not attempt to free this memory. */
    Texture      : PSmFaceTexture;  // Texture for the face region. May be 0 if no texture is produced. Do not attempt to free this memory. */
    OriginWC     : SmCoord3F;       // The origin of the head, in world coordinates. @see sm_api_coord_frames_standard */
    OriginPC     : SmPixel;         // The origin of the head, in pixel coordinates. @note Only currently used by smFaceSearch(). @see sm_api_coord_frames_standard */
  end;

  SmImageHandle  = Integer;
  SmCameraHandle = Integer;

  SmVideoDisplayHandle = Integer;

  SmCameraVideoFormat = record
    Res          : SmSize2i;
    Format       : Integer;
    FrameRate    : Single;
    IsUpsideDown : Bool; // 4 bytes
  end;
  PSmCameraVideoFormat = ^SmCameraVideoFormat;

  SmCameraLensParams = record
    FocalLength    : SmCoord2d; // Focal length (in pixels) for each axis X,Y.
    PrincipalPoint : SmCoord2d; // Principal point of the lens (in pixels).
    Skew           : Double;    // Skew (defines the angle between X and Y axes), dimensionless.
    K1,K2,K3,K4,K5 : Double;    // Lens distortion coefficients, dimensionless. */
    CalibRes       : SmSize2I;  // Image resolution at which the lens-parameters were calibrated.
  end;
  PSmCameraLensParams = ^SmCameraLensParams;

  SmCameraVideoFrame = record    // 24?
    ImageHandle : SmImageHandle; // 4 - The video-frame image.
    FrameNum    : DWord;         // 4 - Specifies the position in the video-sequence. Always increases with time.
    Time        : SmTime;        // 12 - UTC time of image exposure, accurate to 1ms.
  end;
  PSmCameraVideoFrame = ^SmCameraVideoFrame;

  SmCameraSettings = record

// Optional lens model for the camera, can be 0.
// If set, it must point to a valid smCameraLensParams struct that has been
//  initialized using smCameraLoadLensParamsFile() or smCameraLensParamsFromHFOV()
    LensParams : PSmCameraLensParams;

// Optional approximate field-of-view of the camera in degrees, can be 0.
// If set, it will be used only if no lens_params are provided. The value must be between [1,179] degrees.
// If 0 and lens_params is also 0 then a default field-of-view will be used. */
    ApproxFovDeg : PInteger;

// Optional format index, can be 0.
// If 0, the preferred smCameraVideoFormat will be used as specified by @a preferred_format_index in smCameraInfo.
// If set, it must point to an integer which has a value from 0 to smCameraInfo.num_formats-1.
// For file-cameras and image-push cameras, this setting is ignored.
    FormatIndex : PInteger;
  end;
  PSmCameraSettings = ^SmCameraSettings;

  TSmCameraVideoFormatArray = array of SmCameraVideoFormat;
  PSmCameraVideoFormatArray = ^TSmCameraVideoFormatArray;

  SmCameraInfo = record
    CameraType           : Integer;              // General type of camera. */
    Model                : SmStringHandle;       // Name of the camera model, e.g. "Logitech Quickcam Pro 5000". */
    InstanceIndex        : Integer;              // The Nth camera in this category of cameras. */
    NumFormats           : Integer;              // Number of video formats supported by the camera that are compatible with the API */
    PreferredFormatIndex : Integer;              // The preferred format to use for tracking, as suggested by the API. A value from 0 to num_formats-1. */
    Formats              : PSmCameraVideoFormat; // Array of video formats, or 0 if num_formats == 0. */
    Vec                  : Pointer;              // Internal use only. */
  end;
  PSmCameraInfo = ^SmCameraInfo;

  TSmCameraInfoArray = array of SmCameraInfo;
  PSmCameraInfoArray = ^TSmCameraInfoArray;

  SmCameraInfoList = record
    NumCameras : Integer;            // The number of cameras detected on the system */
    Info       : PSmCameraInfo;//Array; // Array of smCameraInfo, one for each detected camera, or 0 if num_cameras == 0 */
    Vec        : Pointer;            // Internal use only. */
  end;
  PSmCameraInfoList = ^SmCameraInfoList;

// call back type definitions
  SmLoggingCallBack    = procedure(UserData:Pointer;const Buffer:PChar;BufferSize:Integer); stdcall;
  SmHTHeadPoseCallBack = procedure(UserData:Pointer;HeadPose:SmEngineHeadPoseData;Frame:SmCameraVideoFrame); stdcall;
  SmHTFaceDataCallBack = procedure(UserData:Pointer;FaceData:SmEngineFaceData;Frame:SmCameraVideoFrame); stdcall;

//typedef void (STDCALL *smLoggingCallback)(void *user_data, const char *buf, int buf_len);
//typedef void (STDCALL *smHTFaceDataCallback)(void *user_data, smEngineFaceData face_data, smCameraVideoFrame video_frame);
//typedef void (STDCALL *smHTHeadPoseCallback)(void *user_data, smEngineHeadPoseData head_pose, smCameraVideoFrame video_frame);

const
//  SmDLL = 'smft32.dll';
  SmDLL = 'smft40.dll';

// return codes
  SM_API_OK                        = 0;   // API function call was successful.
  SM_API_FAIL_INVALID_CALL         = -1;  // Function is not valid or unsupported.
  SM_API_FAIL_INVALID_ARGUMENT     = -2;  // A bad parameter was passed.
  SM_API_FAIL_CPU_INADEQUATE       = -3;  // CPU features are inadequate for the function.
  SM_API_FAIL_MEMORY_INADEQUATE    = -4;  // Not enough memory for the function.
  SM_API_FAIL_OUT_OF_MEMORY        = -5;  // Ran out of memory while calling the function.
  SM_API_FAIL_OPEN_FILE            = -6;  // A file could not be found or opened.
  SM_API_FAIL_PARSE_FILE           = -7;  // A file format was not recognized.
  SM_API_FAIL_WRITE_FILE           = -8;  // A file or folder could not be created or written.
  SM_API_FAIL_CAMERA_ERROR         = -9;  // Could not find / initialize a camera.
  SM_API_FAIL_NO_LICENSE           = -10; // The license is invalid.
  SM_API_FAIL_INVALID_ENGINE_STATE = -11; // The engine state is invalid for the function call.
  SM_API_FAIL_STD_ERROR            = -12; // Error using the C++ std library
  SM_API_FAIL_UNSPECIFIED          = -13; // An unknown error occured. Check the application log.
  SM_API_FAIL_PROGRAMMING_ERROR    = -14; // An internal check detected an invalid logic condition.
  SM_API_FAIL_CORE_EXCEPTION       = -15; // A core-library exception occured.
  SM_API_FAIL_CAMERA_NOT_STARTED   = -16; // The camera is not started.
  SM_API_FAIL_CAMERA_IMAGE_PUSH    = -17; // Failed to push image into camera.
  SM_API_FAIL_UNITIALIZED          = -18; // The API is not initialized.
  SM_API_FAIL_BUFFER_TOO_SMALL     = -19; // Supplied data buffer is too small.
  SM_API_FAIL_CAMERA_HAS_STARTED   = -20; // The camera has already been started.

  SM_API_FALSE : Integer = 0;
  SM_API_TRUE  : Integer = 1;

// image codes
  SM_API_IMAGECODE_GRAY_8U  = $30303859; // 8-bit per-pixel grayscale.
  SM_API_IMAGECODE_GRAY_16U = 30;        // 16-bit per-pixel grayscale.
  SM_API_IMAGECODE_YUY2     = $32595559; // 16-bit per-pixel packed YUV 4:2:2 format. @see http://www.fourcc.org/yuv.php#YUY2
  SM_API_IMAGECODE_I420     = $30323449; // 12-bit per-pixel planar YUV 4:2:2 format. @see http://www.fourcc.org/yuv.php#IYUV
  SM_API_IMAGECODE_BGRA_32U = 11;        // 32-bit per-pixel BGRA. Byte ordering compatible with Windows 32-bit RGB bitmaps and OpenGL GL_RGBA.
  SM_API_IMAGECODE_ARGB_32U = 12;        // 32-bit per-pixel ARGB.
  SM_API_IMAGECODE_BGR_24U  = 20;        // 24-bit per-pixel BGR. Byte ordering compatible with Windows 24-bit RGB bitmaps.
  SM_API_IMAGECODE_RGB_24U  = 21;        // 24-bit per-pixel RGB.
  SM_API_NUM_IMAGE_CODES    = 8;

// copy modes
  SM_API_IMAGE_MEMORYCOPYMODE_DEEP   = 0; // Always deep copy the image memory
  SM_API_IMAGE_MEMORYCOPYMODE_SHARED = 1; // Attempt to share memory (i.e shallow copy). FAILS with an error if not possible due to incorrect alignment. */
  SM_API_IMAGE_MEMORYCOPYMODE_AUTO   = 2; // Share memory when alignment is ok, otherwise deep copy. This is the preferred option. */

// engine types
  SM_API_ENGINE_TYPE_HEAD_TRACKER_V1 = 0; // V1.0 head-tracker. Low CPU. Only 1 engine of this type can be created at a time.
  SM_API_ENGINE_TYPE_HEAD_TRACKER_V2 = 1; // V2.0 head-tracker. Robust. Multiple engines of this type can be created at the same time.
  SM_API_ENGINE_LATEST_HEAD_TRACKER  = 1; // Set to the latest version head tracker.

// Possible states for an API Engine.
  SM_API_ENGINE_STATE_TERMINATED      = 0; // The engine is not yet created or has been destroyed (no resources allocated)
  SM_API_ENGINE_STATE_INVALID         = 1; // The engine is in an invalid state and cannot be used.
  SM_API_ENGINE_STATE_IDLE            = 2; // The engine exists but processing is inactive (not tracking). Video will be shown on a VideoDisplay.
  SM_API_ENGINE_STATE_RECORDING       = 3; // The engine is recording raw images from the camera to disk.
  SM_API_ENGINE_STATE_HT_INITIALIZING = 4; // The head-tracking engine is trying to acquire a new face.
  SM_API_ENGINE_STATE_HT_TRACKING     = 5; // The head-tracking engine is tracking a face.
  SM_API_ENGINE_STATE_HT_SEARCHING    = 6; // The head-tracking engine is searching for an existing face.

// face textures
  SM_ORTHOGRAPHIC_PROJECTION = 0; // The texture is generated from an orthographic projection of the front of the face.

// camera types - smCameraType
  SM_API_CAMERA_TYPE_WDM        = 0; // Windows Driver Model compatible cameras (webcams). */
  SM_API_CAMERA_TYPE_PTGREY     = 1; // PointGrey firewire cameras. */
  SM_API_CAMERA_TYPE_IMAGE_PUSH = 2; // "Push" camera, allowing user to supply image memory data. */
  SM_API_CAMERA_TYPE_FILE       = 3; // File camera, reading images from a suitable movie files. */
  SM_API_CAMERA_NUM_TYPES       = 4; // The number of supported camera types */

// camera exposure modes
  SM_API_EXPOSURE_MODE_NONE = 0;             //*!< Indicates that the camera has no exposure mode options */
  SM_API_EXPOSURE_MODE_AUTO = 1;             //*!< All parameters are automatically controlled by the camera driver. */
  SM_API_EXPOSURE_MODE_FLICKERLESS_50HZ = 2; //*!< Shutter fixed to 10ms to avoid flicker from 50Hz indoor lights. Sensor gain is typically used to adjust image brightness. */
  SM_API_EXPOSURE_MODE_FLICKERLESS_60HZ = 3; //*!< Shutter fixed to 8.3ms to avoid flicker from 60Hz indoor lights. Sensor gain is typically used to adjust image brightness. */
  SM_API_EXPOSURE_MODE_SUNLIGHT = 4;         //*!< Shutter can be varied, and is typically used to adjust image brightness. */
  SM_API_EXPOSURE_MODE_IR = 5;               //*!< Any auto parameters are false. Shutter and gain are typically used to adjust image brightness. This mode used for PtGrey cams with the faceAPI IR Lighting Kit option. */
  SM_API_EXPOSURE_MODE_CUSTOM = 6;           //*!< Custom modes >= 6 */

  SM_API_VIDEO_DISPLAY_REFERENCE_FRAME = $01; // Shows the head coordinate-frame overlay */
  SM_API_VIDEO_DISPLAY_HEAD_MESH       = $02; // Shows a mesh representation of the face */
  SM_API_VIDEO_DISPLAY_PERFORMANCE     = $04; // Shows the CPU load and framerate */
  SM_API_VIDEO_DISPLAY_LANDMARKS       = $08; // Shows the face landmarks being tracked */
  SM_API_VIDEO_DISPLAY_COLOR           = $10; // Shows the display in color if available. Warning, this consumes more CPU than grayscale. */

// api functions
function smAPIVersion(var Major,Minor,Maint:Integer):Integer; stdcall;
function smAPILicenseInfoString(Buffer:PChar;var Size:Integer;Detail:SmBool):Integer; stdcall;
function smAPINonCommercialLicense:SmBool; stdcall;
function smAPIInit:Integer; stdcall;
function smAPIProcessEvents:Integer; stdcall;

// For production license builds, use this function instead of smAPIInit().
//  @param dummy This parameter is reserved for future releases. Pass in null.
//  @return @ref smReturnCode "SM_API_OK" if the function completed successfully.
//  @return @ref smReturnCode "SM_API_FAIL_NO_LICENSE" if a valid license could not be determined.
function smAPIInitProductionLicense(const Dummy:PChar):Integer; stdcall;

// Call at the end of your program to clean up API resources
function smAPIQuit:Integer; stdcall;

// camera functions
//nCode) smCameraCreateImagePush(const smCameraVideoFormat* video_format, int max_fifo_len, const smCameraSettings *settings, smCameraHandle *push_camera_handle);
function smCameraCreateImagePush(const VideoFormat:PSmCameraVideoFormat;MaxFifoLength:Integer;
                                 const Settings:PSmCameraSettings;
                                 var PushCameraHandle:SmCameraHandle):Integer; stdcall;

function smCameraImagePush(CameraHandle:SmCameraHandle;const VideoFrame:PSmCameraVideoFrame;
                           const LenParams:PSmCameraLensParams;SrcRect:PSmImageRect):Integer; stdcall;

function smCameraImagePushBlock(PushCameraHandle:SmCameraHandle;TimeOutMS:Integer;
                                const VideoFrame:SmCameraVideoFrame;
                                LensParams:PSmCameraLensParams;SrcRect:PSmImageRect):Integer; stdcall;

function smCameraCreate(const CameraInfo:SmCameraInfo;Settings:PSmCameraSettings;
                        var CameraHandle:SmCameraHandle):Integer; stdcall;

function smCameraCreateInfoList(var InfoList:SmCameraInfoList):Integer; stdcall;
function smCameraDestroyInfoList(var InfoList:SmCameraInfoList):Integer; stdcall;
function smCameraRegisterType(CameraType:Integer):Integer; stdcall;
function smCameraSetLensParams(CameraHandle:SmCameraHandle;const LensParams:SmCameraLensParams):Integer; stdcall;
function smCameraGetLensParams(CameraHandle:SmCameraHandle;var LensParams:SmCameraLensParams):Integer; stdcall;
function smCameraLensParamsFromHFOV(HFov:Integer;Res:SmSize2I;var LensParams:SmCameraLensParams):Integer; stdcall;

//_smCameraLensParamsFromHFOV@16
//_smCameraLoadLensParamsFile@8

function smCameraGetNumExposureModes(CameraHandle:SmCameraHandle;
                                     var ExposureModes:Integer):Integer; stdcall;

function smCameraEnumExposureModes(CameraHandle:SmCameraHandle;Index:Integer;
                                   var ExposureMode:Integer):Integer; stdcall;

function smCameraGetExposureMode(CameraHandle:SmCameraHandle;
                                 var ExposureMode:Integer):Integer; stdcall;

function smCameraSetExposureMode(CameraHandle:SmCameraHandle;
                                 ExposureMode:Integer):Integer; stdcall;

function smCameraSetReflectionMinimize(CameraHandle:SmCameraHandle;Enabled:SmBool):Integer; stdcall;

function smCameraGetReflectionMinimize(CameraHandle:SmCameraHandle;var Enabled:SmBool):Integer; stdcall;
function smCameraSetImageBrightness(CameraHandle:SmCameraHandle;BrightnessPercent:Integer):Integer; stdcall;
function smCameraGetImageBrightness(CameraHandle:SmCameraHandle;var BrightnessPercent:Integer):Integer; stdcall;
function smCameraDestroy(var CameraHandle:SmCameraHandle):Integer; stdcall;
function smCameraShowControlPanel(CameraHandle:SmCameraHandle):Integer; stdcall;
function smCameraHasControlPanel(CameraHandle:SmCameraHandle;var Result:SmBool):Integer; stdcall;

//function smCameraPtGreyRestoreMemoryChannel(smCameraHandle ptgrey_camera_handle, int channel_num);
//SM_API(smReturnCode) smCameraSetLensParams(smCameraHandle camera_handle, const smCameraLensParams* lens_params);
//SM_API(smReturnCode) smCameraGetLensParams(smCameraHandle camera_handle, smCameraLensParams *lens_params);

// engine functions
function smEngineCreate(EngineType:Integer;EngineHandle:PSmEngineHandle):Integer; stdcall;

function smEngineCreateWithCamera(EngineType:Integer;CameraHandle:SmCameraHandle;
                                  var EngineHandle:SmEngineHandle):Integer; stdcall;

function smEngineStart(EngineHandle:SmEngineHandle):Integer; stdcall;
function smEngineStop(EngineHandle:SmEngineHandle):Integer; stdcall;

function smEngineDestroy(var EngineHandle:SmEngineHandle):Integer; stdcall;

function SmEngineIsLicensed(EngineHandle:SmEngineHandle):Integer; stdcall;

function SmEngineGetCamera(EngineHandle:SmEngineHandle;var CameraHandle:SmCameraHandle):Integer; stdcall;

// tracker functions
function smHTV2SetRealtimeTracking(EngineHandle:SmEngineHandle;Enabled:SmBool):Integer; stdcall;
function smHTSetLipTrackingEnabled(EngineHandle:SmEngineHandle;Enabled:SmBool):Integer; stdcall;
function smHTSetEyebrowTrackingEnabled(EngineHandle:SmEngineHandle;Enabled:SmBool):Integer; stdcall;
function smHTRegisterHeadPoseCallback(EngineHandle:SmEngineHandle;UserData:Pointer;CallBack:SmHTHeadPoseCallBack):Integer; stdcall;
function smHTRegisterFaceDataCallback(EngineHandle:SmEngineHandle;UserData:Pointer;CalkBack:SmHTFaceDataCallback):Integer; stdcall;
function smHTSetTrackingRanges(EngineHandle:SmEngineHandle;Min,Max:Single):Integer; stdcall;
function smHTGetTrackingRanges(EngineHandle:SmEngineHandle;var Min,Max:Single):Integer; stdcall;

// time functions
function smTimeNormalize(var Time:SmTime):Integer; stdcall;
function smTimeSetFromUTC(var Time:SmTime):Integer; stdcall;

{function smTimeSetSecondsPart(int64 secs, smTime *time);
function smTimeSetMicroSecondsPart(int32 usecs, smTime *time);
function smTimeSetSecs(double secs, smTime *time);
function smTimeGetSecs(const smTime* time, double *secs);
function smTimeDiff(const smTime* old, const smTime* young, smTime *diff);
function smTimeAdd(const smTime* t1, const smTime* t2, smTime *add);
function smTimeToString(const smTime* time, smStringHandle sm_string);}

// image functions
function SmImageCreateFromInfo(const ImageInfo:PSmImageInfo;
                               var CopyMode:SmImageMemoryCopyMode;
                               var ImageHandle:SmImageHandle):Integer; stdcall;

function SmImageCreateFromPNG(FileName:SmStringHandle;var ImageHandle:SmImageHandle):Integer; stdcall;

function smImageCreateConvert(SrcImageHandle:SmImageHandle;var NewImageHandle:SmImageHandle;
                              NewImageFormat:SmImageCode):Integer; stdcall;
function smImageDestroy(var ImageHandle:SmImageHandle):Integer; stdcall;
function smImageGetInfo(ImageHandle:SmImageHandle;var Info:smImageInfo):Integer; stdcall;
function smImageSaveToPNG(ImageHandle:SmImageHandle;PngFileName:SmStringHandle):Integer; stdcall;

// string functions
function smStringCreate(var StringHandle:SmStringHandle):Integer; stdcall;
function smStringDestroy(var StringHandle:SmStringHandle):Integer; stdcall;
function smStringGetBufferW(StringHandle:SmStringHandle;var Buf:PWideChar;var BufLen:Integer):Integer; stdcall;
function smStringWriteBuffer(StringHandle:SmStringHandle;Buffer:PChar;BufLen:Integer):Integer; stdcall;
function smStringWriteBufferW(StringHandle:SmStringHandle;Buffer:PWideChar;BufLen:Integer):Integer; stdcall;
{SM_API(smReturnCode) smStringIsValid(smStringHandle string, smBool *valid);
SM_API(smReturnCode) smStringReadBuffer(smStringHandle string, const char *buf, int buf_len);
SM_API(smReturnCode) smStringReadBufferW(smStringHandle string, const wchar_t *buf, int buf_len);
SM_API(smReturnCode) smStringCopy(smStringHandle dst_string, smStringHandle src_string);
SM_API(smReturnCode) smStringIsEqual(smStringHandle string1, smStringHandle string2, smBool *equal);
SM_API(smReturnCode) smStringIsEmpty(smStringHandle string, smBool *empty);
SM_API(smReturnCode) smStringClear(smStringHandle string);
SM_API(smReturnCode) smStringLength(smStringHandle string, int *len);}

// logging functions
function SmLoggingGetPath(Path:SmStringHandle):Integer; stdcall;
function SmLoggingRegisterCallback(UserData:Pointer;CallBack:SmLoggingCallBack):Integer; stdcall;
function SmLoggingSetFileOutputEnable(Enable:Integer):Integer; stdcall;
//SM_API(smReturnCode) smLoggingGetFileOutputEnable(int *enable);
//SM_API(smReturnCode) smLoggingSetPath(smStringHandle path);

// video functions
function SmVideoDisplayCreate(EngineHandle:SmEngineHandle;
                              var VideoHandle:SmVideoDisplayHandle;
                              ParentHandle:SmWindowHandle;Show:Integer):Integer; stdcall;
function SmVideoDisplayDestroy(var VideoHandle:SmVideoDisplayHandle):Integer; stdcall;
function SmVideoDisplaySetFlags(VideoHandle:SmVideoDisplayHandle;Flags:Word):Integer; stdcall;

{SM_API(smReturnCode) smVideoDisplaySetParent(smVideoDisplayHandle display_handle, smWindowHandle parent_handle);
SM_API(smReturnCode) smVideoDisplayShow(smVideoDisplayHandle display_handle, smBool show);
SM_API(smReturnCode) smVideoDisplayGetWindowHandle(smVideoDisplayHandle display_handle, smWindowHandle *window_handle);
SM_API(smReturnCode) smVideoDisplayGetFlags(smVideoDisplayHandle display_handle, unsigned short *flags);
SM_API(smReturnCode) smVideoDisplayRecordingStart(smVideoDisplayHandle display_handle, smStringHandle filepath, smBool compress);
SM_API(smReturnCode) smVideoDisplayRecordingStop(smVideoDisplayHandle display_handle);
SM_API(smReturnCode) smVideoDisplayRecordingCancel(smVideoDisplayHandle display_handle);
SM_API(smReturnCode) smVideoDisplayRecordingStatus(smVideoDisplayHandle display_handle, int* status);}

// coordinate conversion functions
function SmCoordFaceToPixel(const HeadPoseData:SmEngineHeadPoseData;
                            const LensParams:SmCameraLensParams;
                            const FaceCoord:SmFaceCoord;
                            var PixelCoord:SmPixel):Integer; stdcall;
 // const HeadPoseData* head_pose_data
 // const smCameraLensParams* lens_params
 // const smFaceCoord* face_coord
 // smPixel* pixel_coord );

function smCoordFaceToWorld(const HeadPoseData:SmEngineHeadPoseData;
                            const FaceCoord:SmFaceCoord;
                            var WorldCoord:SmCoord3F):Integer; stdcall;

function smCoordWorldToPixel(const LensParams:SmCameraLensParams;
                             const WorldCoord:SmCoord3F;
                             var PixelCoord:SmPixel):Integer; stdcall;

//SM_API(smReturnCode) smCoordFaceToWorld(const smEngineHeadPoseData* head_pose_data, const smFaceCoord* face_coord, smCoord3f* world_coord );
//SM_API(smReturnCode) smCoordWorldToPixel(const smCameraLensParams* lens_params, const smCoord3f* world_coord, smPixel* pixel_coord );
//SM_API(smReturnCode) smCoordFaceToPixel(const smEngineHeadPoseData* head_pose_data, const smCameraLensParams* lens_params, const smFaceCoord* face_coord, smPixel* pixel_coord );

var
  HSmApi : THandle;

//  smAPIVersion: function(Major,Minor,Maint:PInteger):Integer; cdecl;//stdcall;
function SmApiLicenseInfoStr:String;
function SmCameraTypeStr(CameraType:Integer):String;
function SmErrorCodeToStr(Error:Integer):String;
function SmExposureModeToStr(Mode:Integer):String;

function SmImageCodeToStr(Code:Integer):String;

implementation

uses Windows;

function SmImageCodeToStr(Code:Integer):String;
begin
  Case Code of
    SM_API_IMAGECODE_GRAY_8U  : Result:='8-bit per-pixel grayscale';
    SM_API_IMAGECODE_GRAY_16U : Result:='16-bit per-pixel grayscale';
    SM_API_IMAGECODE_YUY2     : Result:='16-bit per-pixel packed YUV 4:2:2';
    SM_API_IMAGECODE_I420     : Result:='12-bit per-pixel planar YUV 4:2:2';
    SM_API_IMAGECODE_BGRA_32U : Result:='32-bit per-pixel BGRA';
    SM_API_IMAGECODE_ARGB_32U : Result:='32-bit per-pixel ARGB';
    SM_API_IMAGECODE_BGR_24U  : Result:='24-bit per-pixel BGR';
    SM_API_IMAGECODE_RGB_24U  : Result:='24-bit per-pixel RGB';
    else Result:='Unknown image code';
  end;
end;

function SmExposureModeToStr(Mode:Integer):String;
begin
  Case Mode of
    SM_API_EXPOSURE_MODE_NONE             : Result:='No options';
    SM_API_EXPOSURE_MODE_AUTO             : Result:='Auto';
    SM_API_EXPOSURE_MODE_FLICKERLESS_50HZ : Result:='Flickerless - 50Hz';
    SM_API_EXPOSURE_MODE_FLICKERLESS_60HZ : Result:='Flickerless - 60Hz';
    SM_API_EXPOSURE_MODE_SUNLIGHT         : Result:='Sunlight';
    SM_API_EXPOSURE_MODE_IR               : Result:='IR';
    SM_API_EXPOSURE_MODE_CUSTOM           : Result:='Custom';
  end;
end;

function SmErrorCodeToStr(Error:Integer):String;
begin
  Case Error of
    SM_API_OK                        : Result:='API function call was successful.';
    SM_API_FAIL_INVALID_CALL         : Result:='Function is not valid or unsupported.';
    SM_API_FAIL_INVALID_ARGUMENT     : Result:='A bad parameter was passed.';
    SM_API_FAIL_CPU_INADEQUATE       : Result:='CPU features are inadequate for the function.';
    SM_API_FAIL_MEMORY_INADEQUATE    : Result:='Not enough memory for the function.';
    SM_API_FAIL_OUT_OF_MEMORY        : Result:='Ran out of memory while calling the function.';
    SM_API_FAIL_OPEN_FILE            : Result:='A file could not be found or opened.';
    SM_API_FAIL_PARSE_FILE           : Result:='A file format was not recognized.';
    SM_API_FAIL_WRITE_FILE           : Result:='A file or folder could not be created or written.';
    SM_API_FAIL_CAMERA_ERROR         : Result:='Could not find / initialize a camera.';
    SM_API_FAIL_NO_LICENSE           : Result:='The license is invalid.';
    SM_API_FAIL_INVALID_ENGINE_STATE : Result:='The engine state is invalid for the function call.';
    SM_API_FAIL_STD_ERROR            : Result:='Error using the C++ std library';
    SM_API_FAIL_UNSPECIFIED          : Result:='An unknown error occured. Check the application log.';
    SM_API_FAIL_PROGRAMMING_ERROR    : Result:='An internal check detected an invalid logic condition.';
    SM_API_FAIL_CORE_EXCEPTION       : Result:='A core-library exception occured.';
    SM_API_FAIL_CAMERA_NOT_STARTED   : Result:='The camera is not started.';
    SM_API_FAIL_CAMERA_IMAGE_PUSH    : Result:='Failed to push image into camera.';
    SM_API_FAIL_UNITIALIZED          : Result:='The API is not initialized.';
    SM_API_FAIL_BUFFER_TOO_SMALL     : Result:='Supplied data buffer is too small.';
    SM_API_FAIL_CAMERA_HAS_STARTED   : Result:='The camera has already been started.';
  end;
end;

// api
function smAPIVersion; external SmDLL name '_smAPIVersion@12';
function smAPILicenseInfoString; external SmDLL name '_smAPILicenseInfoString@12';
function smAPINonCommercialLicense; external SmDLL name '_smAPINonCommercialLicense@0';

function smAPIInit; external SmDLL name '_smAPIInit@0';
//function smAPIInit; external SmDLL name 'smAPIInit@0';

function smAPIInitProductionLicense; external SmDLL name '_smAPIInitProductionLicense@4';
function smAPIQuit; external SmDLL name '_smAPIQuit@0';
function smAPIProcessEvents; external SmDLL name '_smAPIProcessEvents@0';

{_smAPIEnterModalLoop@0
_smAPIExitModalLoop@0
_smAPIInternalQtGuiDisable@0
_smAPIInternalQtGuiIsDisabled@0
_smAPISetIconFromPNG@4}

// camera
function smCameraCreateImagePush; external SmDLL name '_smCameraCreateImagePush@16';
function smCameraImagePush; external SmDLL name '_smCameraImagePush@16';
function smCameraImagePushBlock; external SmDLL name '_smCameraImagePushBlock@20';
function smCameraCreateInfoList; external SmDLL name '_smCameraCreateInfoList@4';
function smCameraCreate; external SmDLL name '_smCameraCreate@12';
function smCameraDestroyInfoList; external SmDLL name '_smCameraDestroyInfoList@4';
function smCameraRegisterType; external SmDLL name '_smCameraRegisterType@4';
function SmCameraGetLensParams; external SmDLL name '_smCameraGetLensParams@8';
function SmCameraSetLensParams; external SmDLL name '_smCameraSetLensParams@8';
function smCameraGetNumExposureModes; external SmDLL name '_smCameraGetNumExposureModes@8';
function smCameraEnumExposureModes; external SmDLL name '_smCameraEnumExposureModes@12';
function smCameraGetExposureMode; external SmDLL name '_smCameraGetExposureMode@8';
function smCameraSetExposureMode; external SmDLL name '_smCameraSetExposureMode@8';
function smCameraSetReflectionMinimize; external SmDLL name '_smCameraSetReflectionMinimize@8';
function smCameraGetReflectionMinimize; external SmDLL name '_smCameraGetReflectionMinimize@8';
function smCameraSetImageBrightness; external SmDLL name '_smCameraSetImageBrightness@8';
function smCameraGetImageBrightness; external SmDLL name '_smCameraGetImageBrightness@8';
function smCameraDestroy; external SmDLL name '_smCameraDestroy@4';
function smCameraShowControlPanel; external SmDLL name '_smCameraShowControlPanel@4';
function smCameraHasControlPanel; external SmDLL name '_smCameraHasControlPanel@8';
function smCameraLensParamsFromHFOV; external SmDLL name '_smCameraLensParamsFromHFOV@16';
//_smCameraLoadLensParamsFile@8

// engine
function smEngineCreate; external SmDLL name '_smEngineCreate@8';
function smEngineCreateWithCamera; external SmDLL name '_smEngineCreateWithCamera@12';
function smEngineDestroy; external SmDLL name '_smEngineDestroy@4';
function smEngineStart; external SmDLL name '_smEngineStart@4';
function smEngineStop; external SmDLL name '_smEngineStop@4';
function smEngineIsLicensed; external SmDLL name '_smEngineIsLicensed@4';
function SmEngineGetCamera; external SmDLL name '_smEngineGetCamera@8';

// tracker functions
function smHTV2SetRealtimeTracking; external SmDLL name '_smHTV2SetRealtimeTracking@8';
function smHTSetLipTrackingEnabled; external SmDLL name '_smHTSetLipTrackingEnabled@8';
function smHTSetEyebrowTrackingEnabled; external SmDLL name '_smHTSetEyebrowTrackingEnabled@8';
function smHTRegisterHeadPoseCallback; external SmDLL name '_smHTRegisterHeadPoseCallback@12';
function smHTRegisterFaceDataCallback; external SmDLL name '_smHTRegisterFaceDataCallback@12';
function smHTGetTrackingRanges; external SmDLL name '_smHTGetTrackingRanges@12';
function smHTSetTrackingRanges; external SmDLL name '_smHTSetTrackingRanges@12';

// time functions
function smTimeNormalize; external SmDLL name '_smTimeNormalize@4';
function smTimeSetFromUTC; external SmDLL name '_smTimeSetFromUTC@4';

//_smTimeAdd@12
//_smTimeDiff@12
//_smTimeGetSecs@8
//_smTimeNormalize@4
//_smTimeSetMicroSecondsPart@8
//_smTimeSetSecondsPart@12
//_smTimeSetSecs@12
//_smTimeToString@8

// image functions
function smImageGetInfo; external SmDLL name '_smImageGetInfo@8';
function smImageSaveToPNG; external SmDLL name '_smImageSaveToPNG@8';
function smImageDestroy; external SmDLL name '_smImageDestroy@4';
function smImageCreateConvert; external SmDLL name '_smImageCreateConvert@12';
function SmImageCreateFromInfo; external SmDLL name '_smImageCreateFromInfo@12';
function SmImageCreateFromPNG; external SmDLL name '_smImageCreateFromPNG@8';

// string functions
function smStringCreate; external SmDLL name '_smStringCreate@4';
function smStringDestroy; external SmDLL name '_smStringDestroy@4';
function smStringGetBufferW; external SmDLL name '_smStringGetBufferW@12';
function smStringWriteBuffer; external SmDLL name '_smStringWriteBuffer@12';
function smStringWriteBufferW; external SmDLL name '_smStringWriteBufferW@12';

// logging functions
function smLoggingGetPath; external SmDLL name '_smLoggingGetPath@4';
function smLoggingRegisterCallBack; external SmDLL name '_smLoggingRegisterCallback@8';
function smLoggingSetFileOutputEnable; external SmDLL name '_smLoggingSetFileOutputEnable@4';

// video functions
function smVideoDisplayCreate; external SmDLL name '_smVideoDisplayCreate@16';
function smVideoDisplayDestroy; external SmDLL name '_smVideoDisplayDestroy@4';
function smVideoDisplaySetFlags; external SmDLL name '_smVideoDisplaySetFlags@8';
{_smVideoDisplayGetFlags@8
_smVideoDisplayGetWindowHandle@8
_smVideoDisplayRecordingCancel@4
_smVideoDisplayRecordingStart@12
_smVideoDisplayRecordingStatus@8
_smVideoDisplayRecordingStop@4
_smVideoDisplaySetParent@8
_smVideoDisplayShow@8}

// coordinate conversion functions
function SmCoordFaceToPixel; external SmDLL name '_smCoordFaceToPixel@16';
function smCoordFaceToWorld; external SmDLL name '_smCoordFaceToWorld@12';
function smCoordWorldToPixel; external SmDLL name '_smCoordWorldToPixel@12';

function SmCameraTypeStr(CameraType:Integer):String;
begin
  Case CameraType of
    SM_API_CAMERA_TYPE_WDM        : Result:='WDM';
    SM_API_CAMERA_TYPE_PTGREY     : Result:='PointGrey';
    SM_API_CAMERA_TYPE_IMAGE_PUSH : Result:='Push';
    SM_API_CAMERA_TYPE_FILE       : Result:='File';
  end;
end;

function SmApiLicenseInfoStr:String;
var
  Buffer : array of Char;
  Size   : Integer;
  Error  : Integer;
begin
  Error:=smAPILicenseInfoString(nil,Size,SM_API_TRUE);
  if Error=SM_API_OK then begin
    SetLength(Result,Size);
    Error:=smAPILicenseInfoString(@Result[1],Size,SM_API_TRUE);
  end;
end;

{var
  ApiHandle = INVALID_MODULEHANDLE;

procedure InitSmApi;
var
  Address : Pointer;
begin
  ApiHandle:=LoadLibrary(smDLL);
  Address:=GetProcAddress(ApiHandle,'_smAPIInit@0');
  Address:=GetProcAddress(ApiHandle,'_smApiInit');
  Address:=GetProcAddress(ApiHandle,'smApiInit');
end;

procedure ShutDownSmApi;
begin
  if ApiHandle<>INVALID_MODULEHANDLE then begin
    FreeLibrary(ApiHandle);
    ApiHandle:=INVALID_MODULEHANDLE;
  end;
end;}

end.

_smAPIInit@0'
